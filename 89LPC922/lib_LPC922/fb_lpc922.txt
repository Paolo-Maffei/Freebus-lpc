Freebus Library für LPC922
==========================


Globale Variablen, die in der Applikation abgefragt oder geändert werden können:

Bitvariablen:
-------------

ack			wird gesetzt, wenn ein ACK vom Bus empfangen wurde, muss durch die app
			zurückgesetzt werden, wird auch bei Sendebeginn eines Telegramms zurückgesetzt,
			Wert nach hw_restart: 0
			
nack		für NACK, ansonsten s. ack

tel_arrived	wird gesetzt, wenn ein Telegramm empfangen wurde und das Gerät adressiert ist,
			das ist dann der Fall, wenn die Gruppenadresse bekannt ist oder die eigene
			physikalische Adresse das Ziel war oder wenn es ein Broadcast-Telegramm war,
			muss durch die app zurückgesetzt werden, in der Regel ruft die app bei gesetztem
			Bit die Funktion process_tel auf, die das Bit dann zurücksetzt, Wert nach
			hw_restart: 0
			
auto_ack	wenn gesetzt, werden empfangene Telegramme geprüft, ob sie für das Gerät
			gemeint waren, daraufhin wird ein ACK oder NACK automatisch gesendet, Wert
			nach hw_restart: 1
			
unsigned char Variablen:
------------------------

telegramm[23]	Array in dem ein empfangenes oder zu sendendes Telegramm abgelegt wird, 
				sollte in der app nur gelesen werden, hier ist das Telegramm Byte für
				Byte transparent abgelegt, empfangene ACK oder NACK werden hier nicht
				abgelegt
				
telpos			Zeiger auf die nächste freie Position im Array telegramm[], sollte durch
				die app nicht verändert werden

tx_buffer[8]	Ringspeicher für zu sendende Telegramme, hier werden die Objektnummern
				oder Pseudo-Objektnummernn abgelegt und nach FIFO gesendet, sollte durch
				die app nicht direkt beschrieben werden, s. Beschreibung zum Senden weiter
				unten
			
tx_nextwrite	Position der nächsten freien Position in tx_buffer[]

tx_nextsend		Position der nächsten zu sendenden Position in tx_buffer[]

fb_state		Status der Statemachine, sollte in der app nur gelesen werden, Beschreibung
				s. unten, in der Regel wird durch die app nur der Zustand abgefragt um
				festzustellen ob das System beschäftigt oder idle(=0) ist
				
timeout_count	ist >0 wenn nach dem Empfangen oder Senden die obligatorische Pause eingehalten
				wird, wenn 0 dann ist der Bus frei
				
status60		hierhin werden read_memory und write_memory Operationen auf die Speicheradresse
				0x0060 umgeleitet, das ist im sog. USERRAM und entspricht dem Statusbyte,
				Beschreibung s. bcu1_help.pdf
				
eeprom[255]		ist ein Bereich im Flash, der nur gelesen werden kann, entspricht dem sog.
				EEPROM Bereich von 0x0100 bis 0x01FF (s. bcu1_help.pdf), zum Schreiben
				muß der Flashbereich 0x1D00 bis 0x1DFF geflasht werden, dazu stehen Makros
				zur Verfügung (s.u.)
				
userram[255]	wird vermutlich nicht mehr verwendet in Zukunft


Funktionen in der Library:
--------------------------

void X1_int(void)		wird bei Beginn des Startbits am Bus aufgerufen durch externen
						Interrupt 1, nicht in app verwenden!
						
void T1_int(void)		wird durch Timer 1 Interrupt aufgerufen, nicht in app verwenden !

void init_rx(void)		setzt die statemachine in den Anfangszustand, d.h. der Empfang
						ist aktiv, wird als Abschluss der hw_restart() aufgerufen
						
void init_tx(void)		startet unmittelbar das Senden, nicht in app verwenden!

void init_repeat_tx(void)	
						wird nach dem Senden für das eventuelle Wiederholte Senden
						gestartet, nicht in app verwenden!
							
unsigned char gapos_in_gat(unsigned char gah, unsigned char gal)
						sucht zu einer Gruppenadresse (gah=MSB, gal=LSB) den Eintrag in
						der group_adress_table und gibt die Position des Eintrages zurück
						
bit build_mctel(unsigned char objno)
						erzeugt ein Telegramm im Array telegramm[], nicht in APP verwenden!
						
unsigned int find_ga(unsigned char objno)
						findet in der Assoziationstabelle die erste Gruppenadresse, die der
						Objektnummer(objno) zugeordnet ist, dient zum Senden eines
						Objektzustandes, gibt die Gruppenadresse zurück bzw. 0x0000 falls
						keine gefunden wurde
						
unsigned char read_obj_type(unsigned char objno)
						gibt den Objekttyp aus der Kommunikationsobjekttabelle zurück
						
void send_obj_value(unsigned char objno)
						mit diesem Funktionsaufruf wird ein Telegramm gesendet, objno ist
						entweder die Objektnummer, dann wird der Objektwert des Objektes als 
						EIS Telegramm gesendet, addiert man 0x40 zur Objektnummer wird
						der Objektwert als read_request_response Telegramm gesendet, 
						Objektnummern größer 128 sind Systemtelegramme und brauchen von der
						app nicht verwendet werden
					
void set_timer0(unsigned int deltime)
						startet Timer 0 mit dem übergebenen Wert, die Zeit bis zum Überlauf
						sind 0,27127µs x deltime plus 12µs für den Aufruf an sich, der Timer 0 
						ist ausschliesslich für die app reserviert
						
void start_rtc(unsigned char base)
						startet die real time clock, base ist im ms anzugeben
						
void stop_rtc(void)		stoppt die realtime clock

void restart_hw(void)	setzt das gesamte system in den Ausgangszustand zurück und initiiert
						das Empfangen
						
void process_tel(void)	wenn die app die Bitvariable tel_arrived ausgewertet hat, sollte
						diese Funktion aufgerufen werden, es werden alle Telegramm-Typen
						analysiert und die Unicast und Broadcast Telegramme direkt
						abgearbeitet, wenn es ein Multicast Telegramm war, dann wird
						entweder die Funktion read_value_req() oder write_value_req()
						in der app aufgerufen
						
void write_memory(void)	Funktion zum Speicher schreiben bei Unicast, wird für app nicht
						gebraucht
						
void set_pa(void)		Funktion zum Schreiben der phys. Adr. bei Unicast, wird für app nicht
						gebraucht
						
unsigned char read_objflags(unsigned char objno)
						liest die Objektflags eines Objektes (Lesen, Schreiben, Kommunikation,
						etc.)
						
unsigned char find_first_objno(unsigned char gah, unsigned char gal)
						findet die erste vorkommende Objektnummer zu einer Gruppenadresse
						

Folgende Funktionen müssen in der app vorhanden sein, da sie von der Library aufgerufen werden:
-----------------------------------------------------------------------------------------------

void write_value_req(void)
						wird beim eintreffen eines Multicast Telegrammes vom Typ 
						write_value_request aufgerufen, die app muss hier die entsprechende
						Aktion veranlassen, die dazu nötigen Daten lassen sich aus
						telegramm[] entnehmen 

void read_value_req(void)
						wird beim eintreffen eines Multicast Telegrammes vom Typ 
						read_value_request aufgerufen, die app muss hier die entsprechende
						Aktion veranlassen, die dazu nötigen Daten lassen sich aus
						telegramm[] entnehmen
						
unsigned int read_obj_value(unsigned char objno)
						muss den Wert eines Objektes zurückgeben
						
void write_obj_value(unsigned char objno,unsigned int objvalue)
						muss den übergebenen Wert (objvalue) eines Objektes (objno) 
						apspeichern, so daß er später mit read_obj_value() wieder
						gelesen werden kann

void restart_app(void)	muß die Applikations Variablen zurücksetzen, wird zB. durch
						ein restar_request Telegramm aufgerufen, was am Ende der Programmierung
						von der ETS gesendet wird
						
			
Senden eines Telegrammes aus der app:
-------------------------------------

Man ermittelt die Objektnummer dessen Wert gesendet werden soll. Es ist sicherzustellen, daß
man den Wert des Objektes vorher mit write_obj_value() gespeichert hat. Dann wird einfach
die Funktion send_obj_value(objno) aufgerufen. Das Senden erfolgt komplett im 
Hintergrund. Man kann also ruhig mehrere Telegramme direkt hintereinander senden. Der
Ringspeicher reicht für 8 Telegramme, was im Normalfall völlig ausreicht. Sollten doch
einmal mehr als 8 Telegramme gesendet werden, kan man über tx_nextwrite und tx_nextsend das
Sendeverhalten überwachen.


Zeitverhalten der Library:
--------------------------

Alle Funktionen werden per Interrupt aufgerufen. Die App muß also damit umgehen können, daß
in der Regel alle 35µs eine kurze Unterbrechung erfolgt, die im Bereich einiger µs liegt. In
zwei Fällen wird ins Flash geschrieben und der Controller wird für 4ms in den Idle-Zustand
vesetzt: 
- bei memory_write Operationen, z.B. beim Programmieren der Parameter und Gruppenadressen
  durch ETS
- beim Schreiben der physikalischen Adresse durch ETS 
Diese langen Unterbrechungen erfolgen also nur beim Programmieren, im Normalbetrieb ist
kommt das nicht vor.



==> comments to kubi, thx!
